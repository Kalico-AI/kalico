/* tslint:disable */
/* eslint-disable */
/**
 * Foodwallah API
 * REST API for Foodwallah backend services
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BlogPost
 */
export interface BlogPost {
    /**
     * 
     * @type {number}
     * @memberof BlogPost
     */
    doc_id?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    post_url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    tags?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    summary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    author?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BlogPost
     */
    date_created?: number;
    /**
     * 
     * @type {number}
     * @memberof BlogPost
     */
    date_published?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    status?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BlogPost
     */
    is_featured?: boolean | null;
    /**
     * 
     * @type {CompleteRecipe}
     * @memberof BlogPost
     */
    recipe?: CompleteRecipe | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    slug?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    primary_thumbnail?: string | null;
    /**
     * 
     * @type {VideoMetadata}
     * @memberof BlogPost
     */
    video_metadata?: VideoMetadata | null;
}
/**
 * 
 * @export
 * @interface BlogPostResponse
 */
export interface BlogPostResponse {
    /**
     * 
     * @type {BlogPost}
     * @memberof BlogPostResponse
     */
    blog_post?: BlogPost;
    /**
     * 
     * @type {string}
     * @memberof BlogPostResponse
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface BlogVideoContent
 */
export interface BlogVideoContent {
    /**
     * 
     * @type {string}
     * @memberof BlogVideoContent
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof BlogVideoContent
     */
    transcript: string;
}
/**
 * 
 * @export
 * @interface BookmarkRequest
 */
export interface BookmarkRequest {
    /**
     * 
     * @type {string}
     * @memberof BookmarkRequest
     */
    user_id: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkRequest
     */
    doc_id: number;
}
/**
 * 
 * @export
 * @interface CmsVideoContent
 */
export interface CmsVideoContent {
    /**
     * 
     * @type {number}
     * @memberof CmsVideoContent
     */
    doc_id: number;
    /**
     * 
     * @type {string}
     * @memberof CmsVideoContent
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof CmsVideoContent
     */
    raw_transcript?: string;
    /**
     * 
     * @type {string}
     * @memberof CmsVideoContent
     */
    on_screen_text: string;
    /**
     * 
     * @type {string}
     * @memberof CmsVideoContent
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof CmsVideoContent
     */
    caption: string | null;
}
/**
 * 
 * @export
 * @interface CompleteRecipe
 */
export interface CompleteRecipe {
    /**
     * 
     * @type {string}
     * @memberof CompleteRecipe
     */
    cuisine?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompleteRecipe
     */
    original_source?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompleteRecipe
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompleteRecipe
     */
    prep_time?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof CompleteRecipe
     */
    ingredients?: Array<Ingredient>;
    /**
     * 
     * @type {Array<RecipeStep>}
     * @memberof CompleteRecipe
     */
    steps?: Array<RecipeStep>;
}
/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    error?: string | null;
}
/**
 * 
 * @export
 * @interface GifRequest
 */
export interface GifRequest {
    /**
     * 
     * @type {number}
     * @memberof GifRequest
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof GifRequest
     */
    end?: number;
    /**
     * 
     * @type {number}
     * @memberof GifRequest
     */
    doc_id?: number;
}
/**
 * 
 * @export
 * @interface GifResponse
 */
export interface GifResponse {
    /**
     * 
     * @type {string}
     * @memberof GifResponse
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof GifResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GifResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    units: string;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    sort_order: number;
}
/**
 * 
 * @export
 * @interface IngredientContent
 */
export interface IngredientContent {
    /**
     * 
     * @type {number}
     * @memberof IngredientContent
     */
    doc_id: number;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof IngredientContent
     */
    ingredients: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface PageableResponse
 */
export interface PageableResponse {
    /**
     * 
     * @type {number}
     * @memberof PageableResponse
     */
    total_records: number;
    /**
     * 
     * @type {number}
     * @memberof PageableResponse
     */
    num_pages: number;
    /**
     * 
     * @type {Array<BlogPost>}
     * @memberof PageableResponse
     */
    records: Array<BlogPost>;
}
/**
 * 
 * @export
 * @interface PostBody
 */
export interface PostBody {
    /**
     * 
     * @type {number}
     * @memberof PostBody
     */
    doc_id: number;
    /**
     * 
     * @type {string}
     * @memberof PostBody
     */
    body: string;
}
/**
 * 
 * @export
 * @interface RecipeContent
 */
export interface RecipeContent {
    /**
     * 
     * @type {number}
     * @memberof RecipeContent
     */
    doc_id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeContent
     */
    sampling_rate: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeContent
     */
    primary_thumbnail: string;
    /**
     * 
     * @type {Array<RecipeStep>}
     * @memberof RecipeContent
     */
    recipe_steps: Array<RecipeStep>;
}
/**
 * 
 * @export
 * @interface RecipeStep
 */
export interface RecipeStep {
    /**
     * 
     * @type {number}
     * @memberof RecipeStep
     */
    step_number: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeStep
     */
    image_url: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStep
     */
    description: string;
}
/**
 * 
 * @export
 * @interface Slug
 */
export interface Slug {
    /**
     * 
     * @type {string}
     * @memberof Slug
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    firebase_id: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    picture: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof UserProfile
     */
    roles: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof UserProfile
     */
    is_authorized: boolean;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    error: string;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserProfileResponse
     */
    profile: UserProfile;
}
/**
 * 
 * @export
 * @interface VideoMetadata
 */
export interface VideoMetadata {
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    cdn_url: string;
    /**
     * 
     * @type {number}
     * @memberof VideoMetadata
     */
    like_count: number;
    /**
     * 
     * @type {number}
     * @memberof VideoMetadata
     */
    share_count: number;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    caption: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    creator_avatar: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    creator_handle: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    original_source: string;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    cover_image: string | null;
}

/**
 * BlogApi - axios parameter creator
 * @export
 */
export const BlogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bookmark a post for a user
         * @summary Bookmark a post for a user
         * @param {Slug} slug Create bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('createBookmark', 'slug', slug)
            const localVarPath = `/user/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all published posts
         * @summary Get all published posts
         * @param {number} pageNumber 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublishedPosts: async (pageNumber: number, limit: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getAllPublishedPosts', 'pageNumber', pageNumber)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getAllPublishedPosts', 'limit', limit)
            const localVarPath = `/blog/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogIngredients: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getBlogIngredients', 'slug', slug)
            const localVarPath = `/blog/ingredients/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogVideoContent: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getBlogVideoContent', 'slug', slug)
            const localVarPath = `/blog/video-content/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all bookmarked posts
         * @summary Get all bookmarked posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkedPosts: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBookmarkedPosts', 'userId', userId)
            const localVarPath = `/user/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all featured posts
         * @summary Get all featured posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedPosts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog/featured`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get full blog post by slug
         * @summary Get full blog post by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullBlogPost: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getFullBlogPost', 'slug', slug)
            const localVarPath = `/blog/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all submissions by user Id
         * @summary Get all submissions by user Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubmissions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserSubmissions', 'userId', userId)
            const localVarPath = `/user/submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increment share count
         * @summary Increment share count
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementShareCount: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('incrementShareCount', 'slug', slug)
            const localVarPath = `/blog/post/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Like a post
         * @summary Like a post
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likePost: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('likePost', 'slug', slug)
            const localVarPath = `/user/post/like`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate recipe video processing
         * @summary Initiate recipe video processing
         * @param {Array<string>} requestBody Process video request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processVideoRecipe: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('processVideoRecipe', 'requestBody', requestBody)
            const localVarPath = `/user/post/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an existing bookmark
         * @summary Remove an existing bookmark
         * @param {Slug} slug Remove bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmark: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('removeBookmark', 'slug', slug)
            const localVarPath = `/user/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogApi - functional programming interface
 * @export
 */
export const BlogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogApiAxiosParamCreator(configuration)
    return {
        /**
         * Bookmark a post for a user
         * @summary Bookmark a post for a user
         * @param {Slug} slug Create bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmark(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmark(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all published posts
         * @summary Get all published posts
         * @param {number} pageNumber 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPublishedPosts(pageNumber: number, limit: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPublishedPosts(pageNumber, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogIngredients(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngredientContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogIngredients(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogVideoContent(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogVideoContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogVideoContent(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all bookmarked posts
         * @summary Get all bookmarked posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarkedPosts(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlogPost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkedPosts(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all featured posts
         * @summary Get all featured posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturedPosts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlogPost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturedPosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get full blog post by slug
         * @summary Get full blog post by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullBlogPost(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullBlogPost(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all submissions by user Id
         * @summary Get all submissions by user Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSubmissions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlogPost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSubmissions(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Increment share count
         * @summary Increment share count
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incrementShareCount(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.incrementShareCount(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Like a post
         * @summary Like a post
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async likePost(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.likePost(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate recipe video processing
         * @summary Initiate recipe video processing
         * @param {Array<string>} requestBody Process video request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processVideoRecipe(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processVideoRecipe(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an existing bookmark
         * @summary Remove an existing bookmark
         * @param {Slug} slug Remove bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBookmark(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBookmark(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlogApi - factory interface
 * @export
 */
export const BlogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogApiFp(configuration)
    return {
        /**
         * Bookmark a post for a user
         * @summary Bookmark a post for a user
         * @param {Slug} slug Create bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.createBookmark(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all published posts
         * @summary Get all published posts
         * @param {number} pageNumber 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublishedPosts(pageNumber: number, limit: number, options?: any): AxiosPromise<PageableResponse> {
            return localVarFp.getAllPublishedPosts(pageNumber, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogIngredients(slug: string, options?: any): AxiosPromise<IngredientContent> {
            return localVarFp.getBlogIngredients(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogVideoContent(slug: string, options?: any): AxiosPromise<BlogVideoContent> {
            return localVarFp.getBlogVideoContent(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all bookmarked posts
         * @summary Get all bookmarked posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkedPosts(userId: string, options?: any): AxiosPromise<Array<BlogPost>> {
            return localVarFp.getBookmarkedPosts(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all featured posts
         * @summary Get all featured posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturedPosts(options?: any): AxiosPromise<Array<BlogPost>> {
            return localVarFp.getFeaturedPosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get full blog post by slug
         * @summary Get full blog post by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullBlogPost(slug: string, options?: any): AxiosPromise<BlogPost> {
            return localVarFp.getFullBlogPost(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all submissions by user Id
         * @summary Get all submissions by user Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubmissions(userId: string, options?: any): AxiosPromise<Array<BlogPost>> {
            return localVarFp.getUserSubmissions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Increment share count
         * @summary Increment share count
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incrementShareCount(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.incrementShareCount(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Like a post
         * @summary Like a post
         * @param {Slug} slug Post update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likePost(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.likePost(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate recipe video processing
         * @summary Initiate recipe video processing
         * @param {Array<string>} requestBody Process video request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processVideoRecipe(requestBody: Array<string>, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.processVideoRecipe(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an existing bookmark
         * @summary Remove an existing bookmark
         * @param {Slug} slug Remove bookmark request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmark(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.removeBookmark(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogApi - object-oriented interface
 * @export
 * @class BlogApi
 * @extends {BaseAPI}
 */
export class BlogApi extends BaseAPI {
    /**
     * Bookmark a post for a user
     * @summary Bookmark a post for a user
     * @param {Slug} slug Create bookmark request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public createBookmark(slug: Slug, options?: any) {
        return BlogApiFp(this.configuration).createBookmark(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all published posts
     * @summary Get all published posts
     * @param {number} pageNumber 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getAllPublishedPosts(pageNumber: number, limit: number, options?: any) {
        return BlogApiFp(this.configuration).getAllPublishedPosts(pageNumber, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ingredients for full blog post
     * @summary Get ingredients for full blog post
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getBlogIngredients(slug: string, options?: any) {
        return BlogApiFp(this.configuration).getBlogIngredients(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get video content for a full blog post
     * @summary Get video content for a full blog post
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getBlogVideoContent(slug: string, options?: any) {
        return BlogApiFp(this.configuration).getBlogVideoContent(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all bookmarked posts
     * @summary Get all bookmarked posts
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getBookmarkedPosts(userId: string, options?: any) {
        return BlogApiFp(this.configuration).getBookmarkedPosts(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all featured posts
     * @summary Get all featured posts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getFeaturedPosts(options?: any) {
        return BlogApiFp(this.configuration).getFeaturedPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get full blog post by slug
     * @summary Get full blog post by slug
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getFullBlogPost(slug: string, options?: any) {
        return BlogApiFp(this.configuration).getFullBlogPost(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all submissions by user Id
     * @summary Get all submissions by user Id
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public getUserSubmissions(userId: string, options?: any) {
        return BlogApiFp(this.configuration).getUserSubmissions(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Increment share count
     * @summary Increment share count
     * @param {Slug} slug Post update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public incrementShareCount(slug: Slug, options?: any) {
        return BlogApiFp(this.configuration).incrementShareCount(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Like a post
     * @summary Like a post
     * @param {Slug} slug Post update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public likePost(slug: Slug, options?: any) {
        return BlogApiFp(this.configuration).likePost(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate recipe video processing
     * @summary Initiate recipe video processing
     * @param {Array<string>} requestBody Process video request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public processVideoRecipe(requestBody: Array<string>, options?: any) {
        return BlogApiFp(this.configuration).processVideoRecipe(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an existing bookmark
     * @summary Remove an existing bookmark
     * @param {Slug} slug Remove bookmark request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public removeBookmark(slug: Slug, options?: any) {
        return BlogApiFp(this.configuration).removeBookmark(slug, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CmsApi - axios parameter creator
 * @export
 */
export const CmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a gif
         * @param {string} body Delete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGif: async (body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteGif', 'body', body)
            const localVarPath = `/cms/gif/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a GIF from a video file
         * @summary Generate a GIF from a video file
         * @param {GifRequest} gifRequest Generate GIF request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateGif: async (gifRequest: GifRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gifRequest' is not null or undefined
            assertParamExists('generateGif', 'gifRequest', gifRequest)
            const localVarPath = `/cms/gif/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gifRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of posts
         * @summary Get list of posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cms/posts/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmsVideoContent: async (docId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getCmsVideoContent', 'docId', docId)
            const localVarPath = `/cms/post/video-content/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIngredients: async (docId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getIngredients', 'docId', docId)
            const localVarPath = `/cms/post/ingredients/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a post by document slug
         * @summary Get a post by document slug
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (docId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getPostById', 'docId', docId)
            const localVarPath = `/cms/posts/{docId}`
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get image content for a full blog post
         * @summary Get image content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeContent: async (docId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getRecipeContent', 'docId', docId)
            const localVarPath = `/cms/post/recipe-steps/{docId}`
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get video sampled images
         * @summary Get video sampled images
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampledImages: async (docId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getSampledImages', 'docId', docId)
            const localVarPath = `/cms/post/sampled-images/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a post
         * @summary Publish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishBlogPost: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('publishBlogPost', 'slug', slug)
            const localVarPath = `/cms/post/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish a post
         * @summary Unpublish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unPublishBlogPost: async (slug: Slug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('unPublishBlogPost', 'slug', slug)
            const localVarPath = `/cms/post/unpublish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update video data
         * @summary Create or update video data
         * @param {CmsVideoContent} cmsVideoContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmsVideoContent: async (cmsVideoContent: CmsVideoContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmsVideoContent' is not null or undefined
            assertParamExists('updateCmsVideoContent', 'cmsVideoContent', cmsVideoContent)
            const localVarPath = `/cms/post/video-content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmsVideoContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a post
         * @summary Create or update a post
         * @param {BlogPost} blogPost Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertBlogPost: async (blogPost: BlogPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogPost' is not null or undefined
            assertParamExists('upsertBlogPost', 'blogPost', blogPost)
            const localVarPath = `/cms/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blogPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update ingredient list
         * @summary Create or update ingredient list
         * @param {IngredientContent} ingredientContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertIngredients: async (ingredientContent: IngredientContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientContent' is not null or undefined
            assertParamExists('upsertIngredients', 'ingredientContent', ingredientContent)
            const localVarPath = `/cms/post/ingredients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update image data
         * @summary Create or update image data
         * @param {RecipeContent} recipeContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRecipeStep: async (recipeContent: RecipeContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeContent' is not null or undefined
            assertParamExists('upsertRecipeStep', 'recipeContent', recipeContent)
            const localVarPath = `/cms/post/recipe-steps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CmsApi - functional programming interface
 * @export
 */
export const CmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a gif
         * @param {string} body Delete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGif(body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGif(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a GIF from a video file
         * @summary Generate a GIF from a video file
         * @param {GifRequest} gifRequest Generate GIF request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateGif(gifRequest: GifRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GifResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateGif(gifRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of posts
         * @summary Get list of posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlogPost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmsVideoContent(docId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmsVideoContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmsVideoContent(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIngredients(docId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngredientContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIngredients(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a post by document slug
         * @summary Get a post by document slug
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(docId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get image content for a full blog post
         * @summary Get image content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipeContent(docId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipeContent(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get video sampled images
         * @summary Get video sampled images
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampledImages(docId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampledImages(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Publish a post
         * @summary Publish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishBlogPost(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishBlogPost(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unpublish a post
         * @summary Unpublish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unPublishBlogPost(slug: Slug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unPublishBlogPost(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update video data
         * @summary Create or update video data
         * @param {CmsVideoContent} cmsVideoContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCmsVideoContent(cmsVideoContent: CmsVideoContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCmsVideoContent(cmsVideoContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update a post
         * @summary Create or update a post
         * @param {BlogPost} blogPost Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertBlogPost(blogPost: BlogPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertBlogPost(blogPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update ingredient list
         * @summary Create or update ingredient list
         * @param {IngredientContent} ingredientContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertIngredients(ingredientContent: IngredientContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertIngredients(ingredientContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update image data
         * @summary Create or update image data
         * @param {RecipeContent} recipeContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertRecipeStep(recipeContent: RecipeContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertRecipeStep(recipeContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CmsApi - factory interface
 * @export
 */
export const CmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CmsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a gif
         * @param {string} body Delete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGif(body: string, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.deleteGif(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a GIF from a video file
         * @summary Generate a GIF from a video file
         * @param {GifRequest} gifRequest Generate GIF request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateGif(gifRequest: GifRequest, options?: any): AxiosPromise<GifResponse> {
            return localVarFp.generateGif(gifRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of posts
         * @summary Get list of posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(options?: any): AxiosPromise<Array<BlogPost>> {
            return localVarFp.getAllPosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get video content for a full blog post
         * @summary Get video content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmsVideoContent(docId: number, options?: any): AxiosPromise<CmsVideoContent> {
            return localVarFp.getCmsVideoContent(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ingredients for full blog post
         * @summary Get ingredients for full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIngredients(docId: number, options?: any): AxiosPromise<IngredientContent> {
            return localVarFp.getIngredients(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a post by document slug
         * @summary Get a post by document slug
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(docId: number, options?: any): AxiosPromise<BlogPost> {
            return localVarFp.getPostById(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get image content for a full blog post
         * @summary Get image content for a full blog post
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeContent(docId: number, options?: any): AxiosPromise<RecipeContent> {
            return localVarFp.getRecipeContent(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get video sampled images
         * @summary Get video sampled images
         * @param {number} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampledImages(docId: number, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getSampledImages(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a post
         * @summary Publish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishBlogPost(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.publishBlogPost(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish a post
         * @summary Unpublish a post
         * @param {Slug} slug Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unPublishBlogPost(slug: Slug, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.unPublishBlogPost(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update video data
         * @summary Create or update video data
         * @param {CmsVideoContent} cmsVideoContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmsVideoContent(cmsVideoContent: CmsVideoContent, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.updateCmsVideoContent(cmsVideoContent, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a post
         * @summary Create or update a post
         * @param {BlogPost} blogPost Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertBlogPost(blogPost: BlogPost, options?: any): AxiosPromise<BlogPostResponse> {
            return localVarFp.upsertBlogPost(blogPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update ingredient list
         * @summary Create or update ingredient list
         * @param {IngredientContent} ingredientContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertIngredients(ingredientContent: IngredientContent, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.upsertIngredients(ingredientContent, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update image data
         * @summary Create or update image data
         * @param {RecipeContent} recipeContent Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertRecipeStep(recipeContent: RecipeContent, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.upsertRecipeStep(recipeContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CmsApi - object-oriented interface
 * @export
 * @class CmsApi
 * @extends {BaseAPI}
 */
export class CmsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a gif
     * @param {string} body Delete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public deleteGif(body: string, options?: any) {
        return CmsApiFp(this.configuration).deleteGif(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a GIF from a video file
     * @summary Generate a GIF from a video file
     * @param {GifRequest} gifRequest Generate GIF request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public generateGif(gifRequest: GifRequest, options?: any) {
        return CmsApiFp(this.configuration).generateGif(gifRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of posts
     * @summary Get list of posts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getAllPosts(options?: any) {
        return CmsApiFp(this.configuration).getAllPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get video content for a full blog post
     * @summary Get video content for a full blog post
     * @param {number} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getCmsVideoContent(docId: number, options?: any) {
        return CmsApiFp(this.configuration).getCmsVideoContent(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ingredients for full blog post
     * @summary Get ingredients for full blog post
     * @param {number} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getIngredients(docId: number, options?: any) {
        return CmsApiFp(this.configuration).getIngredients(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a post by document slug
     * @summary Get a post by document slug
     * @param {number} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getPostById(docId: number, options?: any) {
        return CmsApiFp(this.configuration).getPostById(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get image content for a full blog post
     * @summary Get image content for a full blog post
     * @param {number} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getRecipeContent(docId: number, options?: any) {
        return CmsApiFp(this.configuration).getRecipeContent(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get video sampled images
     * @summary Get video sampled images
     * @param {number} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public getSampledImages(docId: number, options?: any) {
        return CmsApiFp(this.configuration).getSampledImages(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a post
     * @summary Publish a post
     * @param {Slug} slug Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public publishBlogPost(slug: Slug, options?: any) {
        return CmsApiFp(this.configuration).publishBlogPost(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish a post
     * @summary Unpublish a post
     * @param {Slug} slug Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public unPublishBlogPost(slug: Slug, options?: any) {
        return CmsApiFp(this.configuration).unPublishBlogPost(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update video data
     * @summary Create or update video data
     * @param {CmsVideoContent} cmsVideoContent Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public updateCmsVideoContent(cmsVideoContent: CmsVideoContent, options?: any) {
        return CmsApiFp(this.configuration).updateCmsVideoContent(cmsVideoContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a post
     * @summary Create or update a post
     * @param {BlogPost} blogPost Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public upsertBlogPost(blogPost: BlogPost, options?: any) {
        return CmsApiFp(this.configuration).upsertBlogPost(blogPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update ingredient list
     * @summary Create or update ingredient list
     * @param {IngredientContent} ingredientContent Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public upsertIngredients(ingredientContent: IngredientContent, options?: any) {
        return CmsApiFp(this.configuration).upsertIngredients(ingredientContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update image data
     * @summary Create or update image data
     * @param {RecipeContent} recipeContent Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsApi
     */
    public upsertRecipeStep(recipeContent: RecipeContent, options?: any) {
        return CmsApiFp(this.configuration).upsertRecipeStep(recipeContent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user profile if exists or create one if the user is pre-approved
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserprofile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user profile if exists or create one if the user is pre-approved
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserprofile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserprofile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get user profile if exists or create one if the user is pre-approved
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserprofile(options?: any): AxiosPromise<UserProfileResponse> {
            return localVarFp.getUserprofile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get user profile if exists or create one if the user is pre-approved
     * @summary Get user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserprofile(options?: any) {
        return UserApiFp(this.configuration).getUserprofile(options).then((request) => request(this.axios, this.basePath));
    }
}


